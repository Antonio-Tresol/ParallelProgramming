// for this example we have to distribute the work units between the threads and processes
// In order to do that, we recieve by command line the start work unit and the end work unit to distribute
// the first units before the start work unit are distributed to the first process (main host)
// the other ones are distributed to the other processes
// here we havae a problem, because we have to distribute the work units between the processes
// starting from the first work unit which might not be 0 (as we use in the formula to calculate the work units interval)
// so we use reindexation to solver the issue.
procedure main(argc, argv[])
  if argc = 3 then // we check if the user has entered the correct number of arguments
    shared const overall_start = integer(argv[1])   // the first argument is the starting number
    shared const overall_finish = integer(argv[2])  // the second argument is the ending number
   // MPI does not have a built-in function to disrtibute the work among the processes and threads
    // so we have to do it manually
    // here will do block mapping distribution 
    shared const process_start = calculate_start(process_number \
      , overall_finish, process_count, overall_start)
    shared const process_finish = calculate_finish(process_number \
      , overall_finish, process_count, overall_start)
    shared const process_size = process_finish - process_start
    // E.g: hostname2:1: range [12, 20[ size 8
    print process_hostname, ':', process_number, ": range [", process_start
      , ", ", process_finish, "[ size ", process_size
// here we calculate the range of work units for  thread
// here we are using openmp so, we solve the problem sequentially (instead of using parallel)
// and the we add the parallel pragma to the for loop so that it will be executed in parallel
    parallel do
      // will save some mark for each thread to know where did it start and where did it finish
      declare thread_start := -1
      declare thread_finish := -1
       // here we calculate the range of work units for  thread
      parallel for index := process_start to process_finish using block mapping do
        if thread_start = -1 then
          thread_start := index
        end if
        thread_finish := index
      end for

      thread_finish := thread_finish + 1 // we add 1 because the for loop does not include the last element
      declare constant thread_size = thread_finish - thread_start // the size of the work units for the thread
      // E.g: hostname2:1.1: range [15,18[ size 3
      print '\t', process_hostname, ':', process_number, '.', thread_number, \
        ": range [", thread_start, ", ",  thread_finish, "[ size ", thread_size
    end parallel
  end if
end procedure

function calculate_start(rank, end, workers, begin = 0)
  declare constant range = end - begin // the range of the numbers to check is the end minus the begin
  return begin + rank * div(range, workers) + min(rank, mod(range, workers))  // the formula to calculate the start work unit
  // whew i is rank, range is D, and w is workers and begin is an operator to displace the range of the function
end function

function calculate_finish(rank, end, workers, begin)
  return calculate_start(rank + 1, end, workers, begin)
end function