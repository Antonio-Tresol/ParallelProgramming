/** @brief SUMMARY of the pseudocode: 
* @details :
1. We do a procedure to read a series of numbers from the user and 
   store in a array of nodes of information.
    1.1 The array of nodes is a  array and the node will store the:
    - the number
    - a dynamic array of strings (grows as needed) sums of the number
2. we distrubute the work units between the threads using static block mapping
3. We do a procedure to produce a array of prime number with the 
   sieve Atkin algorithm.
4. Each threads does the procedure to compute the goldbach sums of the
   numbers and store them in the dynamic array of strings for the block range of
   units it was assign to.
@notes:
note: in this code we use int for a number n ∈ Z, that is, an interger in 
mathemathics
note 2: in this code we use array indexation from 1 to n.
*/
declare cordinates:
   int start
   int finish
/*
-------PRIVATE AND SHARED MEMORY------------------------------------------------
*/
// shared memory
Declare Shared_Memory:
   Array_of_Nodes:= A // array of nodes of information
   int max //the biggest number in all the work units
   Array_of_Primes:= P // array of prime numbers
   Array_of_Booleans:= S // sieve of Atkin
//END PRIVATE AND SHARED MEMORY-------------------------------------------------

/*
-------MAIN---------------------------------------------------------------------
*/
procedure main(arguments v):
   // read the numbers
   thread_count := MaxAmountOfThreads // get the max amount of threads
   if v.length := 1:
      thread_count = v[1] // get the amount of threads from the user
   end if
   startTeamOfProcess(arguments v)
   process_number := getProcessNumber()
   process_count := getProcessCount()
   declare Shared_Memory mem
   declare Array_of_Nodes A
   declare int max
   declare Array_of_Primes P
   declare Array_of_Booleans S

   if process_count = 1:
      compute_goldbach_alone()
   else:
      compute_goldbach_together()
   end if
end procedure
//END MAIN----------------------------------------------------------------------
/*
-------PROCEDURES OF PROCESSES COORDINATION AND COMMUNICATION--------------------
*/
/**
* @brief this procedure computes the goldbach sums of an array of nodes
* but it is done by a single process
*/
procedure compute_goldbach_alone(Shared_Memory mem, Array_of_Nodes A, int max, Array_of_Primes P, Array_of_Booleans S):
   A := read_numbers(A)
   max = get_max(A)
   S := sieve_atkin(max)
   P := get_primes(P, S)
   set mem:
      Array_of_Nodes := A // array of nodes of information
      int max := max //the biggest number in all the work units
      Array_of_Primes := P // array of prime numbers
      Array_of_Booleans := S // sieve of Atkin
   end set
   // compute the goldbach sums
   compute_goldbach(mem, int thread_count, 1, A.count)
   // print the results
   print_goldbach_sums(A)
end procedure
/**
* @brief this procedure computes the goldbach sums of an array of nodes
* distributed between processes dynamically
* @param process_number the number of the process
*/
procedure compute_goldbach_together(Shared_Memory mem, Array_of_Nodes A,
   int max, Array_of_Primes P, Array_of_Booleans S, process_number, 
   process_count, int thread_count):

   int amount_of_elements
   declare Array_of_coordinates C
   // read the numbers
   if process_number = 0:
      read_numbers(A)
      amount_of_elements = A.count
      max = get_max(A)
   end if
   // share the base information
   if process_number = 0:
      send_base_info(amount_of_elements, max, A)
   else:
      receive_base_info(amount_of_elements, max, A)
   end if
   // get the information needed to compute the goldbach sums
   P := get_primes(max)
   S := get_sieve(max)
   // set the shared memory of the threads
   set mem:
      Array_of_Nodes := A // array of nodes of information
      int max := max //the biggest number in all the work units
      Array_of_Primes := P // array of prime numbers
      Array_of_Booleans := S // sieve of Atkin
   end set
   // wait for everyone to be ready
   barrier(team of processes)
   // distribute the work blocks dynamically between the processes
   int request_id := 0 // the id of the request
   // it is independent of the process number
   int start := -1 // the start_index of the block
   int finish := -1 // the finish_index of the block
   // allows the first process to arrive to the receive to pass it
   // create a max request id
   max_request_num := process_count * 2
   if process_number = 0:
      while request_id < process_count:
         int process := -1
         // receive process number
         receive(process, 1, any_process)
         // send the request id
         send(request_id, 1, process)
         // receive back the request id from the process
         receive(request_id, 1, process)
         // increment the request id
         request_id++
      end while
      for process := 1 to process_count:
         // send the stop signal
         send(request_id, 1, process)
      end for
   else:
      while request_id < max_request_num:
      // waits for the request id to calculate its own block
         // send the process number
         send(process_number, 1, 0)
         // receive the request id from master
         receive(&request_id, 1, any_process)
         // checks if the request_id is valid
         if request_id < max_request_num: // if valid
         // calculates the block
            get_work_units(request_id, process_number, max_request_num, amount_of_elements, &start, &finish)
         // send the request id to the other processes
            if start != finish: // if we have work to do
               send(&request, 1, any_process)
               // save the coordinates
               C.append(codinates(start, finish))
               // compute the goldbach sums of the block
               compute_goldbach(mem, thread_count, start,finish)
            else: // if we don't have work to do
               // receive the request id to stop
               request_id := max_request_num
               // send it to master
               send(&request, 1, 0)
         end if
      end while
      // return the results
   end if

   if process_number != 0:
      send_results(A, C)
   else:
      receive_results(A, process_count)
   end if
   // print the results
   print_goldbach_sums(A)
end procedure
/**
* @brief this procedure sends the base information to the other processes
* @param amount_of_elements the amount of elements in the array of nodes
* @param max the biggest number in all the work units
* @param A the array of nodes
*/
procedure send_base_info(amount_of_elements, max, A, process_count):
   for process := 1 to process_count - 1:
      // send the amount of elements
      send(&amount_of_elements, 1, process)
      // send the max
      send(&max, 1, i)
      for j := 1 to amount_of_elements:
         // send the number
         if A[j].sums != -1: // if it is a non void node
            int signal := 1
            send(&signal, 1, process)
            send(&A[j].number, 1, process)
         else: // if it is a void node
            int signal := 0
            send(&signal, 1, process)
         end if
      end for
   end for
end procedure

/**
* @brief this procedure receives the base information from the process 0
* @param amount_of_elements the amount of elements in the array of nodes
* @param max the biggest number in all the work units
* @param A the array of nodes
*/
procedure receive_base_info(amount_of_elements, max, A):
   // receive the amount of elements
   receive(&amount_of_elements, 1, 0)
   // receive the max
   receive(&max, 1, 0)
   for j := 1 to amount_of_elements:
      // receive the number
      int number := 0
      int signal := 0
      // receive the number
      receive(&signal, 1, 0)
      if signal = 1: // if it is a non void node
         receive(&number, 1, 0)  // receive the number
         A.append(node(number)) // add the node to the array
      else:
         A.append(node(void)) // add the node to the array
      end if
   end for
end procedure
/**
* @brief this procedure sends the results of the goldbach sums to the process 0
* @param A the array of nodes of information
* @param C the array of cordinates of the blocks of work units
* @details it sends only the nodes that were computed by the process using the 
* cordinates.
*/
procedure send_results(A, C, int process_number):
// send the amount of blocks you got
   int amount_of_blocks := C.count
   int process := -1
   receive(process, 1, 0)
   
   if process_number = process:
      send(&amount_of_blocks, 1, 0)
      // start sending the blocks
      if amount_of_blocks > 0: // if we have blocks to send
         for i := 1 to C.count:
            // send the start and finish of the block
            send(&C[i].start, 1, 0)
            send(&C[i].finish, 1, 0)
            // send the block
            for j := C[i].start to C[i].finish:
               send_node(&A[j], 0)
            end for
         end for
      end if
end procedure
/**
* @brief this procedure receives the results of the goldbach sums from the other
* processes
* @param A the array of nodes of information
* @param process_count the amount of processes
*/
procedure receive_results(A, process_count):
   for process := 1 to process_count:
      int amount_of_blocks
      send(&process, 1, process)
      receive(&amount_of_blocks, 1, process)
      if amount_of_blocks > 0: // if we have blocks to receive
         for i := 1 to amount_of_blocks:
            int start
            int finish
            receive(&start, 1, process)
            receive(&finish, 1, process)
            for j := start to finish:
               if A[j].sums != -1: // if it is a non void node
                  receive_node(&A[j], process)
               end if
            end for
         end for
      end if
end procedure
/**
* @brief this procedure sends a node to a process
* @param node the node to send
* @param process the process to send the node to
*/
procedure send_node(node, process_number = 0):
   // send the number
   send(&node.number, 1, process_number)
   // send the amount golbach sums
   send(&node.sums, 1, process_number)
   // if there are goldbach sums stored
   if node.number > 0:
      // send the one by one the array
      for i := 1 to node.sums:
         // send the array, representing one sum.
         // each sum has at most 3 elements
         send(&node.arrayOfSums[i], 1, process_number)
      end for 
   end if 
end procedure
/**
* @brief this procedure receives a node from a process
* @param node the node to receive
* @param process the process to receive the node from
*/
procedure receive_node(node, process_number):
   // receive the number
   receive(&node.number, 1, process_number)
   // receive the amount golbach sums
   receive(&node.sums, 1, process_number)
   // if there are goldbach sums stored
   if node.number > 0:
      // receive the one by one the array
      for i := 1 to node.sums:
         // receive the array, representing one sum.
         // each sum has at most 3 elements
         buffer := arry ints [3]
         receive(&buffer, 1, process_number)
         node.arrayOfSums.append(buffer)
      end for
end procedure
//END PROCEDURES OF PROCESSES CORDINATION AND COMMUNICATION---------------------

/*
--------PROCEDURES INPUTS AND OUTPUTS-------------------------------------------
*/
   /**
   * @brief reads n numbers from the user and stores them in an array of nodes
   * 
   * @return an array of nodes of information (reference/pointer)
   */
procedure read_numbers(): 
      A := array of nodes of information
      while we don't receive a signal do  
          read int n from user 
          add int n in new node of information in A
      end for
end procedure
 /**
 * @brief prints all the goldbach sums of a number for each number in the array
 * of nodes of information
 * @param A the array of nodes of information
 **/
 procedure print_goldbach_sums(an Array of Nodes A):
 for i := 1 to n do // n is the number of nodes in the array
    if A[i] >= upperLimit then// upper limit is ~ := 2^64 
       print number
       print NA
    end if
    else  
       print A[i].numberm //print the number in the node
       print numberOfSums  //printe the amount of goldbach sums we found
       for j := 1 to A[i].numberOfSums do //print the goldbach sums
          for k := 1 to m do // m is the number of numbers in the sum
             print A[i].arrayOfSums[j][k] 
             print " "
          end for
          print jump line
       end for
       end if
    end else
 end for
end procedure
// END PROCEDURES INPUTS AND OUTPUTS---------------------------------------------

/*
--------PROCEDURES SIEVE/PRIME GENERATION---------------------------------------
*/
   /**
   * @brief finds the prime numbers between 2 and n
   * @param limit the maximum number to find the primes
   * @return an array of primes (a mask)
   * @credits: part of this code is based Bhojasia, M. (2022, May 16) and 
   * geeksforgeeks.org  see more in bibliography in main README
   * note: in case of this sieve algorithm not working, Eratosthenes sieve will be used
   */
procedure sieve_atkin(an array of booleans sieve ,an int limit):
   int wlimit := square root of limit
   
   /* 
   As explained by Atkin & Benrstein(2003, p.1023) the idea behind this algorithm
   is to mark out vales using a irreductible quadratic form xy. Thus number 
   p ∈ 1+4Z are cover by 4x^2 + y^2 = p (first condition),
   for p ∈ 7 + 12Z  3x^2 + y^2 = p (second condition), 
   for p ∈ 11 + 12Z 3x^2 - y^2 = p (x > 0, y > 0) (third condition),
   where Z is the unit group. 4x^2 + y^2 = p 

   One way to reduce these conditions is rephrasing them as follows:

   - Condition one: 4x^2 + y^2 = p  is odd and modulo-60 remainder ∈ {1,13,17,29,37,41,49,53}
   - Condition two: 3x^2 + y^2 = p  is odd and modulo-60 remainder ∈ {7,19,31,43}
   - Condition three: 3x^2 - y^2 = p  is odd and modulo-12 remainder ∈ {11,23,47,59} and x > y > 0
   
   Note 1: it must be pointed out that these cuadratic forms are not unique, there 
   could be others that work as well. (Atkin & Benrstein, 2003, pp.1028-1029).
   
   Note 2: some implementations of the sieve Atkin algorithm use modulo-60, 
   nevertheless, the modulo-12 needs less comparisons and gives the same result.
   */
   for x := 1 to wlimit do
      for y := 1 to wlimit do
         n := 4x^2 + y^2
         /* 
         we test the first condition of the sieve of Atkin
         n is odd and modulo-60 remainder ∈ {1,13,17,29,37,41,49,53}
         that is the same as trying n mod 12 ∈ {1,5} 
         */
         if n <= limit and (n mod 12 = 1 or n mod 12 = 5) then
            sieve[n] := true
         end if 
         /* we test the second condition of the sieve of Atkin
         n is odd and modulo-60 remainder ∈ {7,19,31,43}
         that is the same as trying n mod 12 ∈ {7}
         */
         n := 3x^2 + y^2
         if n <= limit and n mod 12 = 7 then
            sieve[n] := true
         end if
         /* we test the third condition of the sieve of Atkin
         n is odd and modulo-12 remainder ∈ {11,23,47,59} and x > y > 0
         that is the same as trying n mod 12 ∈ {11}
         */
         n := 3x^2 - y^2
         if x > y and n <= limit and n mod 12 = 11 then
            sieve[n] := true
         end if
      end for
   end for
   /* 
   then we mark out the multiples of squares 
   */
   for i := 5 to wlimit do
      if sieve[i] = true then
         for j := 1 until j*i^2 <= limit do
            sieve[j*i^2] := false
         end for
      end if
   end for
   set sieve[2] to true
   set sieve[3] to true
   set sieve[5] to true
   return sieve

end procedure
/**
 *@brief fills the array of primes with the first n primes
*@param P the array of primes
 */
 procedure get_array_of_primes(a Sieve S, array of primes P):
   add 2 and 3 to array of primes P
   for i := 1 to S.limit do
      if S.sieve[i] is true then
         P[i] := i
      end if
   end for
   return P
 end procedure
// END PROCEDURES SIEVE/PRIME GENERATION----------------------------------------

/*
--------PROCEDURES WORK DISTRIBUTION--------------------------------------------
*/
/**
* @brief returns two indexes to a process to work on based on request id.
* @details request id is independent of the process id, it is a counter that
* increases every time a process requests work. 
* @param id the request id
* @param n the number of processes
* @param start the start index
* @param finish the end index
* @param amountofelements the amount of elements in the array of nodes of information
* @returns int the index of the current work unit.
*/
procedure get_work_units(int request_id, int process_number, int max_request_num, int amount_of_elements, int start, int finish):
   start := start(request_id, amount_of_elements, max_request_num)
   finish := finish(request_id, amount_of_elements, max_request_num)
end procedure

/**
* @brief finds the start index of the work unit of a thread
* @param i the id of the thread
* @param D the number of work units
* @param w the amount of threads
* @return the start index of the work unit of a thread
*
*/
procedure start(int i, int D, int w):
   int start_index := i * ( D / w ) + min (i, D mod w)
   return start_index
end procedure
/**
* @brief finds the finish index of the work unit of a thread
* @param i the id of the thread
* @param D the number of work units
* @param w the amount of threads
* @return the finish index of the work unit of a thread
*/
procedure finish(int i, int D, int w):
   int end_index := start(i + 1, D, w)
   return end_index
end procedure
/**
* @brief find the minimum of two numbers
* @param a the first number
* @param b the second number
* @return the minimum of a and b
*/
procedure min(int a, int b):
   if a < b:
      return a
   else:
      return b
   end if
end procedure
// END PROCEDURES WORK DISTRIBUTION---------------------------------------------

/*
--------PROCEDURES GOLDBACH COMPUTATIONS----------------------------------------
*/
/**
 * @brief computes the goldbach sums of a even number n and stores them in an 
 * array of strings within the node of information
 * @param P the array of primes
 * @param A the node of information that stores the even number
 * @credits: part of this code is base on examples of code from geekforgeeks.org
 * with modifications made by the author to optimize time complexity.
 * see main README for more information.
 */
procedure goldbach_sums_even(Node A, array of primes P, a sieve S, int max):
/* 
 Must be said that for these procedure we assume we receive a reference to
 the arrays 
*/
   saveSums := make a boolean flag
   //  check if we have to save the sums
   if A.number < 0 then
      saveSums := true
   end if
   int limit := min(|A.number|/ln(A.number), P.length)
   /* 
   as explain by the Prime number Theorem 
   the number of primes less than x is to x/ln(x) when
   x tends to infinity (Crandall & Pomerance, 2005, p. 24). 
   Thus, we will use this as the limit for the for loops
   */
   for i := 1 until limit do  // || absolute value P[i] <=  |A.number|/2
      int  result := |A.number| - P[i]
      // first free optimization
      // we break the loop if the result is negative because it means
      // that the no other prime next in the array will be less will give a
      // non negative result.
      if result < P[i] then
         break
      end if
      if result <= max:
         if S[result] is true and result >= P[i] then /* if result is prime then
                                          here we can search for the result
                                          in the array of primes */
            A.numberOfSums := A.numberOfSums + 1 // increment the amount of sums 
                                                // found
            if saveSums is true then 
               // add the sum to the dynamic array of sums
               Add  result and P[i] to A.arrayOfSums as an Array
               // add the sum to the dynamic array 
            end if
         end if
      end if
   end for
end procedure
/**
 * @brief computes the goldbach sums of a odd number n and stores them in an 
 * array of strings within the node of information
 * @param P the array of primes
 * @param A the node of information with the odd number
 * @credits: part of this code is base on examples of code from geekforgeeks.org, 
 * with modifications made by the author to optimize time complexity.
 * see main README for more information.
 */
procedure goldbach_sums_odd(a Node A, array of primes P, a sieve S, int max):
   SaveSums := make a boolean flag
   //  check if we have to save the sums
   if A.number < 0 then
      saveSums := true
   end if
   int limit = min (|A.number|/ln(A.number), P.length)
   int i;
   int j;
   int k;
   for i:= 1 to limit do // || absolute value i := 1 to |A.number| do  
      first := P[i] // get the first prime number

      for j:= 1 to limit do // || absolute value j := 1 to |A.number| do  
         second := P[j] // get the second prime number
         result := A.number - first - second // compute the result so we can check if it is prime
         // first free optimization
         // we break the loop if the result is negative because it means
         // that the no other prime next in the array will be less will give a
         // non negative result.
         if result < second then
            break
         end if
         if result <= max:
            if S[result] is true and result >= first and result >= second then  /* if result is prime then, here we can search for 
                                          the result in the array of primes to see if the three of them make up*/
               A.numberOfSums := A.numberOfSums + 1 // increment the amount of sums found
               if saveSums is true then 
                  Add first, second and result to A.arrayOfSums as an Array
               end if
            end if
         end if
      end for

end procedure
/**
 * @brief computes the goldbach sums of a number
 * @param P the array of primes
 * @param A the node of information with the odd number
 * @details this procedure is the one that is called from the main program, it
 * checks if the number is even or odd and calls the corresponding procedure
 */
procedure goldbach_sums(a Node A, array of primes P, a sieve S):
   if A.number > upperLimit // upper limit is ~ := 2^64 
      return None
   end if
   else if A.number is even then
      goldbach_sums_even(A, P, S)
   end else if 
   else
      goldbach_sums_odd(A, P, S)
   end if
end procedure

/**
*@brief computes goldbach sums for all the numbers in the array of node
* uses a parallel region to compute the sums in parallel
*@param mem the array of memory of the threads
*@param thread_count the amount of threads
*/
procedure compute_goldbach(Shared_Memory mem, int thread_count, int start, int finish):
   shared_mem := mem
   Array := shared_mem.array_of_nodes
   Primes := shared_mem.primes
   bool Sieve = shared_mem.sieve
   int max := shared_mem.max

   #pragma parallel for dynamic with shared (Array, Primes, Sieve, max)
   for index := start to finish do:
      goldbach_sums(Array[i], Primes, Sieve, max)
   end for
end procedure
// END PROCEDURES GOLDBACH COMPUTATIONS-----------------------------------------